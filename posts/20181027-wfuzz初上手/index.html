<!doctype html><html lang=zh-cn dir=auto data-theme=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Wfuzz初上手 | Unixcs</title>
<meta name=keywords content><meta name=description content="Wfuzz初上手### Wfuzz是啥玩意？wfuzz 是一款Python开发的Web安全模糊测试工具。https://github.com/xmendez/wfuzz
简单粗暴的功能特点记录：


模块化 框架 可编写插件


接口 可处理BurpSuite所抓的请求和响应报文


简而言之就是wfuzz可以用在做请求参数参数类的模糊测试，也可以用来做Web目录扫描等操作。
Wfuzz初体验

安装Wfuzz pip install wfuzz

简单的使用>
wfuzz -w 字典 地址(e.g. https://gh0st.cn/FUZZ)
如上命令使用-w参数指定字典位置，然后跟上一个要测试的地址，所列的例子https://gh0st.cn/FUZZ中有一个FUZZ单词，这个单词可以理解是一个占位符，这样就大概了解了wfuzz的基本运行原理，它会读取字典然后传入占位符进行模糊测试请求。
实际的使用一遍：
返回结果如下：
通过返回结果我们可以知道很多信息，最需要关注的就是ID、Response、 Lines、Word、Chars、Payload这一行，从左往右看，依次是编号、响应状态码、响应报文行数、响应报文字数、响应报文正字符数、测试使用的Payload。
了解Wfuzz通过-h或者--help可以来获取帮助信息。
Wfuzz模块如上所述说到wfuzz是模块化的框架，wfuzz默认自带很多模块，模块分为5种类型分别是：payloads、encoders、iterators、printers和scripts。
通过-e参数可以查看指定模块类型中的模块列表：
payloads类的模块列表如下：
Wfuzz使用从上文知道了wfuzz基于一个非常简单的概念：使用payload来替换相应的FUZZ关键词的位置，FUZZ这样的关键词就是占位符，payload就是输入源。
通过wfuzz -e payloads可以获取payloads类的所有模块列表，使用wfuzz -z help可以获取关于payloads类模块的详细信息，也可以通过--slice参数来过滤返回信息的结果。
e.g. wfuzz -z help --slice &amp;quot;names&amp;quot;
使用（字典）注：命令中的wordlist表示为字典位置


wfuzz -z file --zP fn=wordlist URL/FUZZ


wfuzz -z file,wordlist URL/FUZZ


wfuzz -w wordlist URL/FUZZ


这里有必要说明下，使用命令意义是一样的，都是使用payloads模块类中的file模块，通过wfuzz -z help --slice &amp;quot;file&amp;quot;看如何使用file模块：
通过返回的帮助信息，我们知道这个模块需要一个参数fn，这个参数值为字典文件名（绝对路径）。这样子第一条命令一下子就明白了，wfuzz -z file --zP fn=wordlist URL/FUZZ中的-z file使用模块，--zP fn=wordlist是定义fn参数的值（可以这样理解，–zP 这里的P大写代表 Parameters ，然后其他的都是固有个事）"><meta name=author content="Unixcs"><link rel=canonical href=https://www.fengx.eu.org/posts/20181027-wfuzz%E5%88%9D%E4%B8%8A%E6%89%8B/><link crossorigin=anonymous href=/assets/css/stylesheet.da3211e5ef867bf2b75fd5a6515cfed7195c011e8ab735694e203810a827097b.css integrity="sha256-2jIR5e+Ge/K3X9WmUVz+1xlcAR6KtzVpTiA4EKgnCXs=" rel="preload stylesheet" as=style><link rel=icon href=https://www.fengx.eu.org/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://www.fengx.eu.org/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://www.fengx.eu.org/favicon-32x32.png><link rel=apple-touch-icon href=https://www.fengx.eu.org/apple-touch-icon.png><link rel=mask-icon href=https://www.fengx.eu.org/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=zh-cn href=https://www.fengx.eu.org/posts/20181027-wfuzz%E5%88%9D%E4%B8%8A%E6%89%8B/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51);color-scheme:dark}.list{background:var(--theme)}.toc{background:var(--entry)}}@media(prefers-color-scheme:light){.list::-webkit-scrollbar-thumb{border-color:var(--code-bg)}}</style></noscript><script>localStorage.getItem("pref-theme")==="dark"?document.querySelector("html").dataset.theme="dark":localStorage.getItem("pref-theme")==="light"?document.querySelector("html").dataset.theme="light":window.matchMedia("(prefers-color-scheme: dark)").matches?document.querySelector("html").dataset.theme="dark":document.querySelector("html").dataset.theme="light"</script><meta property="og:url" content="https://www.fengx.eu.org/posts/20181027-wfuzz%E5%88%9D%E4%B8%8A%E6%89%8B/"><meta property="og:site_name" content="Unixcs"><meta property="og:title" content="Wfuzz初上手"><meta property="og:description" content="Wfuzz初上手### Wfuzz是啥玩意？wfuzz 是一款Python开发的Web安全模糊测试工具。https://github.com/xmendez/wfuzz 简单粗暴的功能特点记录：
模块化 框架 可编写插件
接口 可处理BurpSuite所抓的请求和响应报文
简而言之就是wfuzz可以用在做请求参数参数类的模糊测试，也可以用来做Web目录扫描等操作。
Wfuzz初体验 安装Wfuzz pip install wfuzz 简单的使用> wfuzz -w 字典 地址(e.g. https://gh0st.cn/FUZZ)
如上命令使用-w参数指定字典位置，然后跟上一个要测试的地址，所列的例子https://gh0st.cn/FUZZ中有一个FUZZ单词，这个单词可以理解是一个占位符，这样就大概了解了wfuzz的基本运行原理，它会读取字典然后传入占位符进行模糊测试请求。
实际的使用一遍：
返回结果如下：
通过返回结果我们可以知道很多信息，最需要关注的就是ID、Response、 Lines、Word、Chars、Payload这一行，从左往右看，依次是编号、响应状态码、响应报文行数、响应报文字数、响应报文正字符数、测试使用的Payload。
了解Wfuzz通过-h或者--help可以来获取帮助信息。 Wfuzz模块如上所述说到wfuzz是模块化的框架，wfuzz默认自带很多模块，模块分为5种类型分别是：payloads、encoders、iterators、printers和scripts。 通过-e参数可以查看指定模块类型中的模块列表：
payloads类的模块列表如下：
Wfuzz使用从上文知道了wfuzz基于一个非常简单的概念：使用payload来替换相应的FUZZ关键词的位置，FUZZ这样的关键词就是占位符，payload就是输入源。 通过wfuzz -e payloads可以获取payloads类的所有模块列表，使用wfuzz -z help可以获取关于payloads类模块的详细信息，也可以通过--slice参数来过滤返回信息的结果。
e.g. wfuzz -z help --slice &amp;quot;names&amp;quot;
使用（字典）注：命令中的wordlist表示为字典位置 wfuzz -z file --zP fn=wordlist URL/FUZZ
wfuzz -z file,wordlist URL/FUZZ
wfuzz -w wordlist URL/FUZZ
这里有必要说明下，使用命令意义是一样的，都是使用payloads模块类中的file模块，通过wfuzz -z help --slice &amp;quot;file&amp;quot;看如何使用file模块：
通过返回的帮助信息，我们知道这个模块需要一个参数fn，这个参数值为字典文件名（绝对路径）。这样子第一条命令一下子就明白了，wfuzz -z file --zP fn=wordlist URL/FUZZ中的-z file使用模块，--zP fn=wordlist是定义fn参数的值（可以这样理解，–zP 这里的P大写代表 Parameters ，然后其他的都是固有个事）"><meta property="og:locale" content="zh-cn"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2018-10-27T00:00:00+00:00"><meta property="article:modified_time" content="2018-10-27T00:00:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Wfuzz初上手"><meta name=twitter:description content="Wfuzz初上手### Wfuzz是啥玩意？wfuzz 是一款Python开发的Web安全模糊测试工具。https://github.com/xmendez/wfuzz
简单粗暴的功能特点记录：


模块化 框架 可编写插件


接口 可处理BurpSuite所抓的请求和响应报文


简而言之就是wfuzz可以用在做请求参数参数类的模糊测试，也可以用来做Web目录扫描等操作。
Wfuzz初体验

安装Wfuzz pip install wfuzz

简单的使用>
wfuzz -w 字典 地址(e.g. https://gh0st.cn/FUZZ)
如上命令使用-w参数指定字典位置，然后跟上一个要测试的地址，所列的例子https://gh0st.cn/FUZZ中有一个FUZZ单词，这个单词可以理解是一个占位符，这样就大概了解了wfuzz的基本运行原理，它会读取字典然后传入占位符进行模糊测试请求。
实际的使用一遍：
返回结果如下：
通过返回结果我们可以知道很多信息，最需要关注的就是ID、Response、 Lines、Word、Chars、Payload这一行，从左往右看，依次是编号、响应状态码、响应报文行数、响应报文字数、响应报文正字符数、测试使用的Payload。
了解Wfuzz通过-h或者--help可以来获取帮助信息。
Wfuzz模块如上所述说到wfuzz是模块化的框架，wfuzz默认自带很多模块，模块分为5种类型分别是：payloads、encoders、iterators、printers和scripts。
通过-e参数可以查看指定模块类型中的模块列表：
payloads类的模块列表如下：
Wfuzz使用从上文知道了wfuzz基于一个非常简单的概念：使用payload来替换相应的FUZZ关键词的位置，FUZZ这样的关键词就是占位符，payload就是输入源。
通过wfuzz -e payloads可以获取payloads类的所有模块列表，使用wfuzz -z help可以获取关于payloads类模块的详细信息，也可以通过--slice参数来过滤返回信息的结果。
e.g. wfuzz -z help --slice &amp;quot;names&amp;quot;
使用（字典）注：命令中的wordlist表示为字典位置


wfuzz -z file --zP fn=wordlist URL/FUZZ


wfuzz -z file,wordlist URL/FUZZ


wfuzz -w wordlist URL/FUZZ


这里有必要说明下，使用命令意义是一样的，都是使用payloads模块类中的file模块，通过wfuzz -z help --slice &amp;quot;file&amp;quot;看如何使用file模块：
通过返回的帮助信息，我们知道这个模块需要一个参数fn，这个参数值为字典文件名（绝对路径）。这样子第一条命令一下子就明白了，wfuzz -z file --zP fn=wordlist URL/FUZZ中的-z file使用模块，--zP fn=wordlist是定义fn参数的值（可以这样理解，–zP 这里的P大写代表 Parameters ，然后其他的都是固有个事）"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://www.fengx.eu.org/posts/"},{"@type":"ListItem","position":2,"name":"Wfuzz初上手","item":"https://www.fengx.eu.org/posts/20181027-wfuzz%E5%88%9D%E4%B8%8A%E6%89%8B/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Wfuzz初上手","name":"Wfuzz初上手","description":"Wfuzz初上手### Wfuzz是啥玩意？wfuzz 是一款Python开发的Web安全模糊测试工具。https://github.com/xmendez/wfuzz 简单粗暴的功能特点记录：\n模块化 框架 可编写插件\n接口 可处理BurpSuite所抓的请求和响应报文\n简而言之就是wfuzz可以用在做请求参数参数类的模糊测试，也可以用来做Web目录扫描等操作。\nWfuzz初体验 安装Wfuzz pip install wfuzz 简单的使用\u0026gt; wfuzz -w 字典 地址(e.g. https://gh0st.cn/FUZZ)\n如上命令使用-w参数指定字典位置，然后跟上一个要测试的地址，所列的例子https://gh0st.cn/FUZZ中有一个FUZZ单词，这个单词可以理解是一个占位符，这样就大概了解了wfuzz的基本运行原理，它会读取字典然后传入占位符进行模糊测试请求。\n实际的使用一遍：\n返回结果如下：\n通过返回结果我们可以知道很多信息，最需要关注的就是ID、Response、 Lines、Word、Chars、Payload这一行，从左往右看，依次是编号、响应状态码、响应报文行数、响应报文字数、响应报文正字符数、测试使用的Payload。\n了解Wfuzz通过-h或者--help可以来获取帮助信息。 Wfuzz模块如上所述说到wfuzz是模块化的框架，wfuzz默认自带很多模块，模块分为5种类型分别是：payloads、encoders、iterators、printers和scripts。 通过-e参数可以查看指定模块类型中的模块列表：\npayloads类的模块列表如下：\nWfuzz使用从上文知道了wfuzz基于一个非常简单的概念：使用payload来替换相应的FUZZ关键词的位置，FUZZ这样的关键词就是占位符，payload就是输入源。 通过wfuzz -e payloads可以获取payloads类的所有模块列表，使用wfuzz -z help可以获取关于payloads类模块的详细信息，也可以通过--slice参数来过滤返回信息的结果。\ne.g. wfuzz -z help --slice \u0026amp;quot;names\u0026amp;quot;\n使用（字典）注：命令中的wordlist表示为字典位置 wfuzz -z file --zP fn=wordlist URL/FUZZ\nwfuzz -z file,wordlist URL/FUZZ\nwfuzz -w wordlist URL/FUZZ\n这里有必要说明下，使用命令意义是一样的，都是使用payloads模块类中的file模块，通过wfuzz -z help --slice \u0026amp;quot;file\u0026amp;quot;看如何使用file模块：\n通过返回的帮助信息，我们知道这个模块需要一个参数fn，这个参数值为字典文件名（绝对路径）。这样子第一条命令一下子就明白了，wfuzz -z file --zP fn=wordlist URL/FUZZ中的-z file使用模块，--zP fn=wordlist是定义fn参数的值（可以这样理解，–zP 这里的P大写代表 Parameters ，然后其他的都是固有个事）\n","keywords":[],"articleBody":"Wfuzz初上手### Wfuzz是啥玩意？wfuzz 是一款Python开发的Web安全模糊测试工具。https://github.com/xmendez/wfuzz 简单粗暴的功能特点记录：\n模块化 框架 可编写插件\n接口 可处理BurpSuite所抓的请求和响应报文\n简而言之就是wfuzz可以用在做请求参数参数类的模糊测试，也可以用来做Web目录扫描等操作。\nWfuzz初体验 安装Wfuzz pip install wfuzz 简单的使用\u003e wfuzz -w 字典 地址(e.g. https://gh0st.cn/FUZZ)\n如上命令使用-w参数指定字典位置，然后跟上一个要测试的地址，所列的例子https://gh0st.cn/FUZZ中有一个FUZZ单词，这个单词可以理解是一个占位符，这样就大概了解了wfuzz的基本运行原理，它会读取字典然后传入占位符进行模糊测试请求。\n实际的使用一遍：\n返回结果如下：\n通过返回结果我们可以知道很多信息，最需要关注的就是ID、Response、 Lines、Word、Chars、Payload这一行，从左往右看，依次是编号、响应状态码、响应报文行数、响应报文字数、响应报文正字符数、测试使用的Payload。\n了解Wfuzz通过-h或者--help可以来获取帮助信息。 Wfuzz模块如上所述说到wfuzz是模块化的框架，wfuzz默认自带很多模块，模块分为5种类型分别是：payloads、encoders、iterators、printers和scripts。 通过-e参数可以查看指定模块类型中的模块列表：\npayloads类的模块列表如下：\nWfuzz使用从上文知道了wfuzz基于一个非常简单的概念：使用payload来替换相应的FUZZ关键词的位置，FUZZ这样的关键词就是占位符，payload就是输入源。 通过wfuzz -e payloads可以获取payloads类的所有模块列表，使用wfuzz -z help可以获取关于payloads类模块的详细信息，也可以通过--slice参数来过滤返回信息的结果。\ne.g. wfuzz -z help --slice \u0026quot;names\u0026quot;\n使用（字典）注：命令中的wordlist表示为字典位置 wfuzz -z file --zP fn=wordlist URL/FUZZ\nwfuzz -z file,wordlist URL/FUZZ\nwfuzz -w wordlist URL/FUZZ\n这里有必要说明下，使用命令意义是一样的，都是使用payloads模块类中的file模块，通过wfuzz -z help --slice \u0026quot;file\u0026quot;看如何使用file模块：\n通过返回的帮助信息，我们知道这个模块需要一个参数fn，这个参数值为字典文件名（绝对路径）。这样子第一条命令一下子就明白了，wfuzz -z file --zP fn=wordlist URL/FUZZ中的-z file使用模块，--zP fn=wordlist是定义fn参数的值（可以这样理解，–zP 这里的P大写代表 Parameters ，然后其他的都是固有个事）\n第二条命令简写了第一条命令的赋值，第三条命令使用-w，这个参数就是-z file --zP fn的别名。\n多个字典\n使用-z 或-w 参数可以同时指定多个字典，这时相应的占位符应设置为 FUZZ,FUZ2Z,FUZ3Z,….,FUZnZ, 其中n代表了占位序号。\n例如想要同时爆破目录、文件名、后缀，可以这样来玩：\nwfuzz -w 目录字典路径 -w 文件名字典路径 -w 后缀名字典路径 URL/FUZZ/FUZ2Z.FUZ3Z\n过滤器wfuzz具有过滤器功能，在做测试的过程中会因为环境的问题需要进行过滤，例如在做目录扫描的时候，你事先探测并知道了这个网站访问不存在目录的时候使用的是自定义404页面（也就是状态码为200），而你可以选择提取该自定义页面的特征来过滤这些返回结果。 wfuzz过滤分为两种方法：隐藏符合过滤条件的结果 和 显示符合过滤条件的结果\n隐藏响应结果\n通过--hc，--hl，--hw，--hh参数可以隐藏某些HTTP响应。\n--hc 根据响应报文状态码进行隐藏（hide code） 隐藏404：\nwfuzz -w wordlist --hc 404 URL/FUZZ\n隐藏404、403：\nwfuzz -w wordlist --hc 404,403 URL/FUZZ\ne.g. 使用百度举个例子，运行wfuzz -w test_dict.txt https://www.baidu.com/FUZZ结果如下\n这里所有的测试请求，都是不存在的页面，那么百度的404页面规则就是如上图结果所示：响应报文状态码（302）、响应报文行数（7）、响应报文字数（18）、响应报文字符数（222），那么下面的就是填空题了～\n--hl根据响应报文行数进行隐藏（hide lines） wfuzz -w wordlist --hl 7 https://www.baidu.com/FUZZ\n--hw根据响应报文字数进行隐藏（hide word） wfuzz -w wordlist --hw 18 https://www.baidu.com/FUZZ\n--hh根据响应报文字符数进行隐藏（hide chars 这里因为code和chars首字母都是c，–hc参数已经有了，所以hide chars的参数就变成了–hh） wfuzz -w wordlist --hh 222 https://www.baidu.com/FUZZ\n如果根据单个条件判断相对来说肯定是不精确的，所以整合一下就是这样的命令：\n这样就可以对https://www.baidu.com/进行目录扫描咯～\n显示响应结果\n显示响应结果的使用方法跟隐藏时的原理一样，只不过参数变为了：--sc（show code），--sl（show lines），--sw（show word），--sh （show chars）。\n使用Baseline(基准线)\n过滤器可以是某个HTTP响应的引用，这样的引用我们称为Baseline。\n之前的使用--hh进行过滤的例子中，还可以使用下面的命令代替：\n这条命令的意思应该很容易理解，首先要清楚基准线是什么？换个名字：标准线 or 及格线。\n首先解释下https://www.baidu.com/FUZZ{404there}的意思，这里代表wfuzz第一个请求是请求https://www.baidu.com/404there这个网址，在{ }内的值用来指定wfuzz第一个请求中的FUZZ占位符，而这第一个请求被标记为BBB（BBB不能换成别的）基准线；其次这里使用的参数是--hh，也就是以BBB这条请求中的Chars为基准，其他请求的Chars值与BBB相同则隐藏。\n使用正则表达式过滤\nwfuzz参数--ss和--hs可以使用正则表达式来对返回的结果过滤。\ne.g. 在这里一个网站自定义返回页面的内容中包含Not Found，想根据这个内容进行过滤可以使用如下的命令：\n得出结论使用方法：\n手册原文来自：DigApis安全 m0nst3r 模块种类##### payloadpayload为wfuzz生成的用于测试的特定字符串，一般情况下，会替代被测试URL中的FUZZ占位符。 当前版本中的wfuzz中可用payloads列表如下：\nencoderencoder的作用是将payload进行编码或加密。 wfuzz的encoder列表如下：\niteratorwfuzz的iterator提供了针对多个payload的处理方式。 itorators的列表如下：\nprinterwfuzz的printers用于控制输出打印。 printers列表如下：\nscriptsscripts列表如下： 内置工具##### wfencode 工具这是wfuzz自带的一个加密/解密（编码/反编码）工具，目前支持内建的encoders的加/解密。 wfpayload工具wfpayload是payload生成工具 wxfuzz 工具这个看源码是一个wxPython化的wfuzz，也就是GUI图形界面的wfuzz。目前需要wxPython最新版本才能使用，但是在ParrotOS和Kali上都无法正常安装成功，问题已在GitHub提交Issue，期待开发者的回复中… wfuzz命令中文帮助 ps：本文转自key师傅的博客 –\u003e原文\n","wordCount":"191","inLanguage":"zh-cn","datePublished":"2018-10-27T00:00:00Z","dateModified":"2018-10-27T00:00:00Z","author":{"@type":"Person","name":"Unixcs"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://www.fengx.eu.org/posts/20181027-wfuzz%E5%88%9D%E4%B8%8A%E6%89%8B/"},"publisher":{"@type":"Organization","name":"Unixcs","logo":{"@type":"ImageObject","url":"https://www.fengx.eu.org/favicon.ico"}}}</script></head><body id=top><header class=header><nav class=nav><div class=logo><a href=https://www.fengx.eu.org/ accesskey=h title="Unixcs (Alt + H)">Unixcs</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">Wfuzz初上手</h1><div class=post-meta><span title='2018-10-27 00:00:00 +0000 UTC'>October 27, 2018</span>&nbsp;·&nbsp;<span>1 min</span>&nbsp;·&nbsp;<span>191 words</span>&nbsp;·&nbsp;<span>Unixcs</span></div></header><div class=post-content><h2 id=wfuzz初上手-wfuzz是啥玩意wfuzz-是一款python开发的web安全模糊测试工具httpsgithubcomxmendezwfuzz>Wfuzz初上手### Wfuzz是啥玩意？wfuzz 是一款Python开发的Web安全模糊测试工具。<a href=https://github.com/xmendez/wfuzz>https://github.com/xmendez/wfuzz</a><a hidden class=anchor aria-hidden=true href=#wfuzz初上手-wfuzz是啥玩意wfuzz-是一款python开发的web安全模糊测试工具httpsgithubcomxmendezwfuzz>#</a></h2><p>简单粗暴的功能特点记录：</p><ul><li><p>模块化 框架 可编写插件</p></li><li><p>接口 可处理BurpSuite所抓的请求和响应报文</p></li></ul><p>简而言之就是wfuzz可以用在做<strong>请求参数参数类的模糊测试</strong>，也可以用来做<strong>Web目录扫描</strong>等操作。</p><h3 id=wfuzz初体验>Wfuzz初体验<a hidden class=anchor aria-hidden=true href=#wfuzz初体验>#</a></h3><ul><li>安装Wfuzz <code>pip install wfuzz</code></li></ul><h4 id=简单的使用>简单的使用><a hidden class=anchor aria-hidden=true href=#简单的使用>#</a></h4><p>wfuzz -w 字典 地址(e.g. <a href=https://gh0st.cn/FUZZ>https://gh0st.cn/FUZZ</a>)</p><p>如上命令使用-w参数指定字典位置，然后跟上一个要测试的地址，所列的例子<code>https://gh0st.cn/FUZZ</code>中有一个<strong>FUZZ</strong>单词，这个单词可以理解是一个占位符，这样就大概了解了wfuzz的基本运行原理，它会读取字典然后传入占位符进行模糊测试请求。</p><p>实际的使用一遍：</p><p>返回结果如下：</p><p>通过返回结果我们可以知道很多信息，最需要关注的就是<code>ID、Response、 Lines、Word、Chars、Payload</code>这一行，从左往右看，依次是<strong>编号、响应状态码、响应报文行数、响应报文字数、响应报文正字符数、测试使用的Payload</strong>。</p><h4 id=了解wfuzz通过-h或者--help可以来获取帮助信息>了解Wfuzz通过<code>-h</code>或者<code>--help</code>可以来获取帮助信息。<a hidden class=anchor aria-hidden=true href=#了解wfuzz通过-h或者--help可以来获取帮助信息>#</a></h4><h5 id=wfuzz模块如上所述说到wfuzz是模块化的框架wfuzz默认自带很多模块模块分为5种类型分别是payloadsencodersiteratorsprinters和scripts>Wfuzz模块如上所述说到wfuzz是模块化的框架，wfuzz默认自带很多模块，模块分为5种类型分别是：<code>payloads</code>、<code>encoders</code>、<code>iterators</code>、<code>printers</code>和<code>scripts</code>。<a hidden class=anchor aria-hidden=true href=#wfuzz模块如上所述说到wfuzz是模块化的框架wfuzz默认自带很多模块模块分为5种类型分别是payloadsencodersiteratorsprinters和scripts>#</a></h5><p>通过<code>-e</code>参数可以查看指定模块类型中的模块列表：</p><p><code>payloads</code>类的模块列表如下：</p><h4 id=wfuzz使用从上文知道了wfuzz基于一个非常简单的概念使用payload来替换相应的fuzz关键词的位置fuzz这样的关键词就是占位符payload就是输入源>Wfuzz使用从上文知道了wfuzz基于一个非常简单的概念：使用payload来替换相应的FUZZ关键词的位置，FUZZ这样的关键词就是<code>占位符</code>，payload就是输入源。<a hidden class=anchor aria-hidden=true href=#wfuzz使用从上文知道了wfuzz基于一个非常简单的概念使用payload来替换相应的fuzz关键词的位置fuzz这样的关键词就是占位符payload就是输入源>#</a></h4><p>通过<code>wfuzz -e payloads</code>可以获取payloads类的所有模块列表，使用<code>wfuzz -z help</code>可以获取关于payloads类模块的详细信息，也可以通过<code>--slice</code>参数来过滤返回信息的结果。</p><p>e.g. <code>wfuzz -z help --slice &amp;quot;names&amp;quot;</code></p><h5 id=使用字典注命令中的wordlist表示为字典位置>使用（字典）注：命令中的wordlist表示为字典位置<a hidden class=anchor aria-hidden=true href=#使用字典注命令中的wordlist表示为字典位置>#</a></h5><ul><li><p><code>wfuzz -z file --zP fn=wordlist URL/FUZZ</code></p></li><li><p><code>wfuzz -z file,wordlist URL/FUZZ</code></p></li><li><p><code>wfuzz -w wordlist URL/FUZZ</code></p></li></ul><p>这里有必要说明下，使用命令意义是一样的，都是使用<code>payloads</code>模块类中的<code>file</code>模块，通过<code>wfuzz -z help --slice &amp;quot;file&amp;quot;</code>看如何使用<code>file</code>模块：</p><p>通过返回的帮助信息，我们知道这个模块需要一个<strong>参数fn</strong>，这个参数值为字典文件名（绝对路径）。这样子第一条命令一下子就明白了，<code>wfuzz -z file --zP fn=wordlist URL/FUZZ</code>中的<code>-z file</code>使用模块，<code>--zP fn=wordlist</code>是定义<strong>fn参数</strong>的值（可以这样理解，–zP 这里的P大写代表 Parameters ，然后其他的都是固有个事）</p><p>第二条命令简写了第一条命令的赋值，第三条命令使用<code>-w</code>，这个参数就是<code>-z file --zP fn</code>的别名。</p><p><strong>多个字典</strong></p><p>使用<code>-z</code> 或<code>-w</code> 参数可以同时指定多个字典，这时相应的占位符应设置为 <strong>FUZZ,FUZ2Z,FUZ3Z,….,FUZnZ</strong>, 其中<code>n</code>代表了占位序号。</p><p>例如想要同时爆破目录、文件名、后缀，可以这样来玩：</p><p><code>wfuzz -w 目录字典路径 -w 文件名字典路径 -w 后缀名字典路径 URL/FUZZ/FUZ2Z.FUZ3Z</code></p><h5 id=过滤器wfuzz具有过滤器功能在做测试的过程中会因为环境的问题需要进行过滤例如在做目录扫描的时候你事先探测并知道了这个网站访问不存在目录的时候使用的是自定义404页面也就是状态码为200而你可以选择提取该自定义页面的特征来过滤这些返回结果>过滤器wfuzz具有过滤器功能，在做测试的过程中会因为环境的问题需要进行过滤，例如在做目录扫描的时候，你事先探测并知道了这个网站访问不存在目录的时候使用的是自定义404页面（也就是状态码为200），而你可以选择提取该自定义页面的特征来过滤这些返回结果。<a hidden class=anchor aria-hidden=true href=#过滤器wfuzz具有过滤器功能在做测试的过程中会因为环境的问题需要进行过滤例如在做目录扫描的时候你事先探测并知道了这个网站访问不存在目录的时候使用的是自定义404页面也就是状态码为200而你可以选择提取该自定义页面的特征来过滤这些返回结果>#</a></h5><p>wfuzz过滤分为两种方法：<strong>隐藏符合过滤条件的结果</strong> 和 <strong>显示符合过滤条件的结果</strong></p><p><strong>隐藏响应结果</strong></p><p>通过<code>--hc</code>，<code>--hl</code>，<code>--hw</code>，<code>--hh</code>参数可以隐藏某些HTTP响应。</p><ul><li><code>--hc</code> 根据响应报文状态码进行隐藏（hide code）</li></ul><p>隐藏404：</p><p><code>wfuzz -w wordlist --hc 404 URL/FUZZ</code></p><p>隐藏404、403：</p><p><code>wfuzz -w wordlist --hc 404,403 URL/FUZZ</code></p><p>e.g. 使用百度举个例子，运行<code>wfuzz -w test_dict.txt https://www.baidu.com/FUZZ</code>结果如下</p><p>这里所有的测试请求，都是不存在的页面，那么百度的404页面规则就是如上图结果所示：<strong>响应报文状态码（302）、响应报文行数（7）、响应报文字数（18）、响应报文字符数（222）</strong>，那么下面的就是填空题了～</p><ul><li><code>--hl</code>根据响应报文行数进行隐藏（hide lines）</li></ul><p><code>wfuzz -w wordlist --hl 7 https://www.baidu.com/FUZZ</code></p><ul><li><code>--hw</code>根据响应报文字数进行隐藏（hide word）</li></ul><p><code>wfuzz -w wordlist --hw 18 https://www.baidu.com/FUZZ</code></p><ul><li><code>--hh</code>根据响应报文字符数进行隐藏（hide chars 这里因为code和chars首字母都是c，–hc参数已经有了，所以hide chars的参数就变成了–hh）</li></ul><p><code>wfuzz -w wordlist --hh 222 https://www.baidu.com/FUZZ</code></p><p>如果根据单个条件判断相对来说肯定是不精确的，所以整合一下就是这样的命令：</p><p>这样就可以对<code>https://www.baidu.com/</code>进行目录扫描咯～</p><p><strong>显示响应结果</strong></p><p>显示响应结果的使用方法跟隐藏时的原理一样，只不过参数变为了：<code>--sc</code>（show code），<code>--sl</code>（show lines），<code>--sw</code>（show word），<code>--sh</code> （show chars）。</p><p><strong>使用Baseline(基准线)</strong></p><p>过滤器可以是某个HTTP响应的引用，这样的引用我们称为Baseline。</p><p>之前的使用<code>--hh</code>进行过滤的例子中，还可以使用下面的命令代替：</p><p>这条命令的意思应该很容易理解，首先要清楚基准线是什么？换个名字：标准线 or 及格线。</p><p>首先解释下<code>https://www.baidu.com/FUZZ{404there}</code>的意思，这里代表wfuzz第一个请求是请求<code>https://www.baidu.com/404there</code>这个网址，在<code>{ }</code>内的值用来指定wfuzz第一个请求中的FUZZ占位符，而这第一个请求被标记为BBB（<strong>BBB不能换成别的</strong>）基准线；其次这里使用的参数是<code>--hh</code>，<strong>也就是以BBB这条请求中的Chars为基准，其他请求的Chars值与BBB相同则隐藏</strong>。</p><p><strong>使用正则表达式过滤</strong></p><p>wfuzz参数<code>--ss</code>和<code>--hs</code>可以使用正则表达式来对返回的结果过滤。</p><p>e.g. 在这里一个网站自定义返回页面的内容中包含<code>Not Found</code>，想根据这个内容进行过滤可以使用如下的命令：</p><p>得出结论使用方法：</p><h3 id=手册原文来自digapis安全-m0nst3r>手册原文来自：DigApis安全 m0nst3r<a hidden class=anchor aria-hidden=true href=#手册原文来自digapis安全-m0nst3r>#</a></h3><h4 id=模块种类-payloadpayload为wfuzz生成的用于测试的特定字符串一般情况下会替代被测试url中的fuzz占位符>模块种类##### payloadpayload为wfuzz生成的用于测试的特定字符串，一般情况下，会替代被测试URL中的FUZZ占位符。<a hidden class=anchor aria-hidden=true href=#模块种类-payloadpayload为wfuzz生成的用于测试的特定字符串一般情况下会替代被测试url中的fuzz占位符>#</a></h4><p>当前版本中的wfuzz中可用payloads列表如下：</p><h5 id=encoderencoder的作用是将payload进行编码或加密>encoderencoder的作用是将payload进行编码或加密。<a hidden class=anchor aria-hidden=true href=#encoderencoder的作用是将payload进行编码或加密>#</a></h5><p>wfuzz的encoder列表如下：</p><h5 id=iteratorwfuzz的iterator提供了针对多个payload的处理方式>iteratorwfuzz的iterator提供了针对多个payload的处理方式。<a hidden class=anchor aria-hidden=true href=#iteratorwfuzz的iterator提供了针对多个payload的处理方式>#</a></h5><p>itorators的列表如下：</p><h5 id=printerwfuzz的printers用于控制输出打印>printerwfuzz的printers用于控制输出打印。<a hidden class=anchor aria-hidden=true href=#printerwfuzz的printers用于控制输出打印>#</a></h5><p>printers列表如下：</p><h5 id=scriptsscripts列表如下>scriptsscripts列表如下：<a hidden class=anchor aria-hidden=true href=#scriptsscripts列表如下>#</a></h5><h4 id=内置工具-wfencode-工具这是wfuzz自带的一个加密解密编码反编码工具目前支持内建的encoders的加解密>内置工具##### wfencode 工具这是wfuzz自带的一个加密/解密（编码/反编码）工具，目前支持内建的encoders的加/解密。<a hidden class=anchor aria-hidden=true href=#内置工具-wfencode-工具这是wfuzz自带的一个加密解密编码反编码工具目前支持内建的encoders的加解密>#</a></h4><hr><h5 id=wfpayload工具wfpayload是payload生成工具>wfpayload工具wfpayload是payload生成工具<a hidden class=anchor aria-hidden=true href=#wfpayload工具wfpayload是payload生成工具>#</a></h5><h5 id=wxfuzz-工具这个看源码是一个wxpython化的wfuzz也就是gui图形界面的wfuzz目前需要wxpython最新版本才能使用但是在parrotos和kali上都无法正常安装成功问题已在github提交issue期待开发者的回复中>wxfuzz 工具这个看源码是一个wxPython化的wfuzz，也就是GUI图形界面的wfuzz。目前需要wxPython最新版本才能使用，但是在ParrotOS和Kali上都无法正常安装成功，问题已在GitHub提交Issue，期待开发者的回复中…<a hidden class=anchor aria-hidden=true href=#wxfuzz-工具这个看源码是一个wxpython化的wfuzz也就是gui图形界面的wfuzz目前需要wxpython最新版本才能使用但是在parrotos和kali上都无法正常安装成功问题已在github提交issue期待开发者的回复中>#</a></h5><h4 id=wfuzz命令中文帮助>wfuzz命令中文帮助<a hidden class=anchor aria-hidden=true href=#wfuzz命令中文帮助>#</a></h4><hr><p>ps：本文转自key师傅的博客 –><a href=https://gh0st.cn/archives/2018-10-28/1>原文</a></p></div><footer class=post-footer><ul class=post-tags></ul></footer></article></main><footer class=footer><span>&copy; 2026 <a href=https://www.fengx.eu.org/>Unixcs</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");if(menu){const e=localStorage.getItem("menu-scroll-position");e&&(menu.scrollLeft=parseInt(e,10)),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}}document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{const e=document.querySelector("html");e.dataset.theme==="dark"?(e.dataset.theme="light",localStorage.setItem("pref-theme","light")):(e.dataset.theme="dark",localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>