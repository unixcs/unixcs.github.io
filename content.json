{"meta":{"title":"Unixcs","subtitle":"Be the Master of Time!","description":"description","author":"Unixcs","url":"http://unixcs.com","root":"/"},"pages":[{"title":"","date":"2019-06-20T12:58:36.432Z","updated":"2019-06-20T12:58:36.432Z","comments":true,"path":"404.html","permalink":"http://unixcs.com/404.html","excerpt":"","text":"404 body, div, h3, h4, li, ol { margin: 0; padding: 0; } body { font: 14px/1.5 'Microsoft YaHei','微软雅黑',Helvetica,Sans-serif; min-width: 1200px; background: #ffffff; } :focus { outline: 0; } h3, h4, strong { font-weight: 700; } a { color: #428bca; text-decoration: none; } a:hover { text-decoration: underline; } .error-page { background: #ffffff; padding: 80px 0 180px; } .error-page-container { position: relative; z-index: 1; } .error-page-main { position: relative; background: #f9f9f9; margin: 0 auto; width: 617px; -ms-box-sizing: border-box; -webkit-box-sizing: border-box; -moz-box-sizing: border-box; box-sizing: border-box; padding: 50px 50px 70px; } .error-page-main:before { content: ''; display: block; background: url(img/errorPageBorder.png?1427783409637); height: 7px; position: absolute; top: -7px; width: 100%; left: 0; } .error-page-main h3 { text-align:center; font-size: 24px; font-weight: 400; border-bottom: 1px solid #d0d0d0; } .error-page-main h3 strong { font-size: 54px; font-weight: 400; margin-right: 20px; } .error-page-actions div { text-align:right; font-size: 14px; display: inline-block; padding: 30px 0 0 10px; width: 50%; -ms-box-sizing: border-box; -webkit-box-sizing: border-box; -moz-box-sizing: border-box; box-sizing: border-box; color: #838383; } .error-page-actions ol { text-align:center; padding-left: 20px; } .error-page-actions li { line-height: 2.5em; } .error-page-actions:before { content: ''; display: block; position: absolute; z-index: -1; bottom: 17px; left: 50px; width: 200px; height: 10px; -moz-box-shadow: 4px 5px 31px 11px #999; -webkit-box-shadow: 4px 5px 31px 11px #999; box-shadow: 4px 5px 31px 11px #999; -moz-transform: rotate(-4deg); -webkit-transform: rotate(-4deg); -ms-transform: rotate(-4deg); -o-transform: rotate(-4deg); transform: rotate(-4deg); } .error-page-actions:after { content: ''; display: block; position: absolute; z-index: -1; bottom: 17px; right: 50px; width: 200px; height: 10px; -moz-box-shadow: 4px 5px 31px 11px #999; -webkit-box-shadow: 4px 5px 31px 11px #999; box-shadow: 4px 5px 31px 11px #999; -moz-transform: rotate(4deg); -webkit-transform: rotate(4deg); -ms-transform: rotate(4deg); -o-transform: rotate(4deg); transform: rotate(4deg); } 404 Not Found please try again later"},{"title":"About","date":"2019-06-20T08:12:57.000Z","updated":"2019-07-10T13:41:37.991Z","comments":true,"path":"about/index.html","permalink":"http://unixcs.com/about/index.html","excerpt":"","text":"网络安全爱好者。 喜欢三分钟热度。 挣扎着想去改变但又总是不够自律。 这里呢，纯粹的是想给未来的自己留下一点现在的痕迹。"},{"title":"Tags","date":"2019-06-20T08:11:28.000Z","updated":"2019-07-10T13:40:21.048Z","comments":true,"path":"tags/index.html","permalink":"http://unixcs.com/tags/index.html","excerpt":"","text":"{ Web } { Linux } { Python } { Tools } { Blog } { Javascript }"},{"title":"test","date":"2019-05-31T14:41:19.000Z","updated":"2019-05-31T14:41:19.041Z","comments":true,"path":"test/index.html","permalink":"http://unixcs.com/test/index.html","excerpt":"","text":""}],"posts":[{"title":"宽字节注入","slug":"宽字节注入","date":"2019-06-27T08:39:48.000Z","updated":"2019-07-10T12:54:45.759Z","comments":true,"path":"/article/2019-06-27/1/","link":"","permalink":"http://unixcs.com/article/2019-06-27/1/","excerpt":"前言如何解决 注入时 输入的 &nbsp;&nbsp; &#39;(单引号) &nbsp;&nbsp; 被转义成 &nbsp;&nbsp; \\&#39;(反斜杠+单引号)","text":"前言如何解决 注入时 输入的 &nbsp;&nbsp; &#39;(单引号) &nbsp;&nbsp; 被转义成 &nbsp;&nbsp; \\&#39;(反斜杠+单引号) 首先我们来看一下sql注入中遇到的问题 遇到这种情况，说明单引号在插入时被转义了，那么如何去bypass？ 使用宽字节注入，把单引号前的\\给消除掉，这样就可以正常使用单引号去闭合了 这里使用的方法是在单引号前面加上%df。 关于为什么要加上%df就可以宽字节注入了呢？请听我娓娓道来~ 单引号前被插入了 \\ 说明php源码代码中出现了以下函数，那么首先我们要了解一下这些函数。 PHP转义函数 addslashes， mysql_real_escape_string， mysql_escape_string 宽字节注入条件： 使用addslashes函数 (并且开启GPC) 数据库编码设置为GBK (php编码为 utf-8 或其它非GBK格式) 宽字节注入流程： 正常被转义： ‘ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; –&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \\‘ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(单引号 -&gt; 反斜杠+单引号) 加%df 宽字节注入过滤: %df’ &nbsp;&nbsp; –&gt; &nbsp;&nbsp;%df%27% –&gt; &nbsp;&nbsp;%df%5c%27 &nbsp;&nbsp; –&gt; &nbsp;&nbsp;運’ 浏览器输入 –&gt; url编码 &nbsp;&nbsp;&nbsp; –&gt; addslashes转义 &nbsp;&nbsp; –&gt; %df%5c被转义成汉字 運 宽字节注入原理： %df%5c 为什么会被转义成为汉字 運 呢？ %df’经过addslashes编码之后带入了‘\\’ %df’ 就变成了 %df&#39; –&gt; %df%5c%27 (url编码后) %df%5c%27 在带入到mysql时使用了GBK，%df%5c被转译成汉字運 so最后输出结果为 運&#39; 讲到GBK编码转义 为什么%df%5c%27 只转义%5c而不转义%27 呢? GBK编码，它的编码范围是0x8140~0xFEFE（不包括xx7F），在遇到 %df(ascii(223)) &gt; ascii(128) 时自动拼接%5c，因此吃掉‘\\’，而%27、%20小于ascii(128)的字符就保留了。","categories":[],"tags":[{"name":"Web安全","slug":"Web安全","permalink":"http://unixcs.com/tags/Web安全/"}]},{"title":"about study","slug":"about study","date":"2019-06-19T08:53:27.000Z","updated":"2019-07-10T12:57:58.841Z","comments":true,"path":"/article/2019-06-19/1/","link":"","permalink":"http://unixcs.com/article/2019-06-19/1/","excerpt":"前言你的间接性努力就是为了缓解持续性堕落带给你的焦虑而存在的","text":"前言你的间接性努力就是为了缓解持续性堕落带给你的焦虑而存在的 最近状态前段时间在知乎看到一篇关于自律的文章，里面谈到有一种努力叫做间接性努力。 回想自己这段时间的状态，总是被动的去学习，每天生活看似充实但实际上却是瞎几把努力！没有任何用。时间都浪费在琐碎事上去了，本来在学一个新的知识点，发现手机屏幕亮了，就不由自主的拿起手机刷了起来，再回过头来时发现时间已经过去大半，刚才那个知识点还没看完却又已忘的差不多了。周末无聊时总是沉浸在游戏直播，手机app里，压根就没有想到过去学一点东西。喜欢这种短暂的快感,一时的享受。晚上睡觉前想起自己这样的一天时，又开始懊悔不已。。如此往复,周而复始，恶性循环！ 总结：没有目标，缺少努力的动力；漫无目的，逮到什么学什么，看似学了很多，实际都是无用功；容易分心，缺乏自律！ 如何改变 制定目标(由大到小，细化目标) 找到自己真实的发自内心的兴趣点(兴趣才是最好的老师) 自律！约束自己!!(该学学该玩玩，but学的时候一定不能玩！) flag给自己定个小目标，这个月剩下的这几天，把之前落下的视频 基础-进阶 全部补完！争取下个月开始do a Bug Bounty Hunters 学习从来都不是一件轻松的事情，但也要学会苦中作乐，去享受学习的过程~","categories":[],"tags":[{"name":"Study","slug":"Study","permalink":"http://unixcs.com/tags/Study/"}]},{"title":"Windous下Wfuzz的安装","slug":"Windous下Wfuzz的安装","date":"2019-06-13T12:07:54.000Z","updated":"2019-07-10T12:55:14.728Z","comments":true,"path":"/article/2019-06-13/1/","link":"","permalink":"http://unixcs.com/article/2019-06-13/1/","excerpt":"0x00前言wfuzz这个工具在kali下是默认安装的~ 可是由于虚拟机用kali总是有种卡卡的感觉，就想着在windous下也装一个。其实之前我尝试安装过几次，因为没学过python，就一直没有装成功。。还是因为自己菜终于！！！趁着今天下午没事，在 你好表哥 的帮助下~ 终于把这个史诗级的难题给solve了","text":"0x00前言wfuzz这个工具在kali下是默认安装的~ 可是由于虚拟机用kali总是有种卡卡的感觉，就想着在windous下也装一个。其实之前我尝试安装过几次，因为没学过python，就一直没有装成功。。还是因为自己菜终于！！！趁着今天下午没事，在 你好表哥 的帮助下~ 终于把这个史诗级的难题给solve了 关于wfuzz的安装这里介绍两种方法 基于python2.7环境安装 exe版 免python环境，打开即用！！ 早知道有这个版本,我TM还费那么大劲去配置那些看着就脑壳疼的环境干嘛！ 0x01 &ensp;基于python2.7环境安装wufzz首先你要有python2.7+pip的环境，这里环境的安装就不多介绍了~ 直接进入正题 下载wfuzz cmd进入文件根目录 cd wfuzz-2.3.4 ①setup.py install ②pip install -r requirements.txt ③pip install wfuzz ① setup.py是安装程序② requirements.txt 文件是python项目中必须包含一个文件用于记录所有依赖包及其精确的版本号用以新环境部署。这里是安装依赖包③ 安装wfuzz 到这里wfuzz就安装成功了，如何去验证是否安装成功呢？ 在cmd下输入wfuzz 123456789101112131415161718192021222324C:\\Users\\unixcs\\Desktop\\wfuzz-2.3.4&gt;wfuzz********************************************************* Wfuzz 2.4 - The Web Fuzzer ** ** Version up to 1.4c coded by: ** Christian Martorella (cmartorella@edge-security.com) ** Carlos del ojo (deepbit@gmail.com) ** ** Version 1.4d to 2.4 coded by: ** Xavier Mendez (xmendez@edge-security.com) *********************************************************Usage: wfuzz [options] -z payload,params &lt;url&gt; FUZZ, ..., FUZnZ wherever you put these keywords wfuzz will replace them with the values of the specified payload. FUZZ&#123;baseline_value&#125; FUZZ will be replaced by baseline_value. It will be the first request performed and could be used as a base for filtering.Examples: wfuzz -c -z file,users.txt -z file,pass.txt --sc 200 http://www.site.com/log.asp?user=FUZZ&amp;pass=FUZ2Z wfuzz -c -z range,1-10 --hc=BBB http://www.site.com/FUZZ&#123;something not there&#125; wfuzz --script=robots -z list,robots.txt http://www.webscantest.com/FUZZType wfuzz -h for further information or --help for advanced usage. 0x02 &ensp;exe版本的安装 下载下载wfuzz 打开 运行 123456789101112131415161718192021wfuzz.exe -w 1.txt www.baidu.com/FUZZ********************************************************* Wfuzz 2.1 - The Web Bruteforcer *********************************************************Target: http://www.baidu.com/FUZZTotal requests: 4==================================================================ID Response Lines Word Chars Request==================================================================00000: C=302 7 L 18 W 222 Ch \"2\"00001: C=302 7 L 18 W 222 Ch \"3\"00002: C=302 7 L 18 W 222 Ch \"4\"00003: C=302 7 L 18 W 222 Ch \"1\"Total time: 0.296999Processed Requests: 4Filtered Requests: 0Requests/sec.: 13.46801","categories":[],"tags":[{"name":"Tools","slug":"Tools","permalink":"http://unixcs.com/tags/Tools/"}]},{"title":"Docker","slug":"Docker","date":"2019-06-11T06:21:44.000Z","updated":"2019-07-19T07:45:23.169Z","comments":true,"path":"/article/2019-06-11/1/","link":"","permalink":"http://unixcs.com/article/2019-06-11/1/","excerpt":"0x00前言好久没更新博客了，感觉每天都在虚度光阴，要给自己指定一个学习计划，让自己忙起来！！记一下最近刚接触的doker吧，把笔记知识点汇总一下。","text":"0x00前言好久没更新博客了，感觉每天都在虚度光阴，要给自己指定一个学习计划，让自己忙起来！！记一下最近刚接触的doker吧，把笔记知识点汇总一下。 0x01Dcoker 是什么？？ Docker的思想来自于集装箱，集装箱解决了什么问题？在一艘大船上，可以把货物规整的摆放起来。并且各种各样的货物被集装箱标准化了，集装箱和集装箱之间不会互相影响。那么我就不需要专门运送水果的船和专门运送化学品的船了。只要这些货物在集装箱里封装的好好的，那我就可以用一艘大船把他们都运走。 想通俗易懂的了解什么是docker？那就看看这俩例子吧案例1案例2 镜像（image）和容器（container）讲docker 之前必须要提的两个词 镜像 and 容器 那么什么是镜像？什么又是容器呢？ 容器通俗来讲容器就是装东西的箱子，你可以把它理解为 集装箱容器好比软件集装箱，它内部可以安装任何软件和库文件，做任意的运行环境配置。 镜像是静态的。 一个镜像可以创建多个容器。 镜像你可以把镜像看成是我们电脑的里面的 软件安装包Docker运行容器前需要本地存在对应的镜像，一个镜像可以创建多个容器， 容器是动态的。 镜像对于容器只是可读的。 0x02搭建docker主要流程： 找镜像(search) -&gt; 下镜像(pull) -&gt; 查看镜像(images) -&gt; 镜像中创建容器(run) -&gt; 查看容器(ps) 我用的是centos7搭建的docker检查centos版本是否支持docker 1.查看内核版本 (是否大于3.10)uname -r 2.安装dockeryum -y install docker安装最新版本yum -y install docker-ce安装出现问题–&gt;文章 yum install docker-ce- (指定安装版本) systemctl start docker 开启dockersystemctl enable docker 开机启动docker version 查看docker版本号 3.验证是否安装成功 docker run hello-world 到这里其实docker已经安装好了，但！安装好仅仅只是第一步骤；后面还要下载所需的镜像或者使用dockerfile自行构建docker镜像；最后再部署安装你的应用程序到docker容器中。 一. 镜像下载CentOS7 镜像docker pull centos 安装时遇到的问题x509: certificate has expired or is not yet valid错误解决 这个问题基本上是因为证书出现过期导致。 解决办法查看虚拟机和远程服务器的时间是否同步：👇👇date若时间不同步，执行ntpdate cn.pool.ntp.org若安装失败 检查是否安装了ntpateyum install ntpdate -y 镜像命令1.搜索镜像docker search 关键词 2.获取镜像docker pull 仓库名称[:tag] 3.查看镜像docker images 4.删除镜像docker rmi [image id]docker rmi [tag] //仓库名 使用 docker rmi [id] 命令时，必须确保该镜像没有被容器使用才能进行;删除时系统会先删除掉指向该镜像的所有标签，然后删除镜像本身。 5.存出镜像和载入镜像 docker save -o 存储文件名 存储的镜像 二.容器1.创建容器docker createdocker run //创建并启动容器 2.查看容器docker psdocker ps -a // 查看所有docker 3.启动/终止容器docker start [names]docker stop [names] 4.删除容器 终止状态的容器docker rm [CONTAINER ID] 正在运行的容器docker rm -f [CONTAINER ID] 5.进入容器docker exec -it [name] bash 进入容器docker run -i -t centos /bin/bash 创建centos exec是进入已经存在的容器，run是创建新容器 5.退出容器ctrl+d 退出容器且关闭 ctrl+p+q 退出容器但不关闭 docker kill -s HUP [容器名] HUP(1)是让进程挂起，睡眠;kill (9)六亲不认的杀掉term(15)正常的退出进程 0x03docker logs errors and others 遇到问题、运行不了之类的先看日志报错信息! 1. Exited (1) 错误这个报错信息 是我在使用php镜像创建一个新的容器时出现的，当时只知道傻乎乎的的去百度搜，不知道查看docker logs 报错，导致走了很长的弯路！错误原因： php的配置文件里 server 被我打成了erver ，发现这个错误的时候 我真的是想把自己揍一顿(复制粘贴都能错) 总结： 细心细心再细心！！ docker los 命令 12345678docker logs [OPTIONS] CONTAINEROptions: --details 显示更多的信息 -f, --follow 跟踪实时日志 --since string 显示自某个timestamp之后的日志，或相对时间，如42m（即42分钟） --tail string 从日志末尾显示多少行日志， 默认是all -t, --timestamps 显示时间戳 --until string 显示自某个timestamp之前的日志，或相对时间，如42m（即42分钟） 2. 配置没问题，访问搭建的nginx不成功错误原因： 重启下dockerssystemctl restart docker重启容器docker restart [name] 再次访问success！ 进入docker 方法 execdocker exec [names] bash nsenter 1 . 查看容器[id]的进程的PIDdocker inspect -f \\{\\{.State.Pid\\}\\} [CONTAINER ID] 2 . 使用pid进入容器nsenter --target $PID --mount --uts --ipc --net --pid$PID为第一步查询到的PID about nsenter install docker卸载查看已安装的包yum list installed | grep docker 删除包yum -y remove docker-engine.x86_64 推荐两个doker 搭建nginx、php 、mysql 的文章 参考：https://blog.51cto.com/11134648/2160257","categories":[],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://unixcs.com/tags/Linux/"}]},{"title":"about blog","slug":"about blog","date":"2019-06-01T05:15:17.000Z","updated":"2019-06-02T08:57:19.210Z","comments":true,"path":"/article/2019-06-01/1/","link":"","permalink":"http://unixcs.com/article/2019-06-01/1/","excerpt":"0x00前言this is my first blog昨天花了一天时间终于把这个博客开通了，俗话说前人栽树后人乘凉，多亏了一些前辈分享的一些博客，才能这么快上手。不过在这中间还是遇到了许多的坑，可能这些小问题在大佬们看来都不屑去写，但是对于萌新的我来说，这些东西还是要慢慢的去摸索。话不多说，开始填坑。","text":"0x00前言this is my first blog昨天花了一天时间终于把这个博客开通了，俗话说前人栽树后人乘凉，多亏了一些前辈分享的一些博客，才能这么快上手。不过在这中间还是遇到了许多的坑，可能这些小问题在大佬们看来都不屑去写，但是对于萌新的我来说，这些东西还是要慢慢的去摸索。话不多说，开始填坑。 0x01首先介绍下博客的环境github+hexo+node.js (我使用的是win) 搭建过程前期搭建的具体过程我就不一一叙述了，网上的例子很多，这里贴两个我搭建过程中参考的文章。 case1 case2 0x02简单的记一下一些错误 1.找不到 .sshcd ~/.ssh ？？黑人问号？？ 百度了N遍都没讲到点子上，最后终于在一个老哥的CSDN的文章里找到了解决办法，这里记录一下 解决方法：这里其实就是因为我们是第一次使用，~目录里缺少 .ssh文件夹这时候我们该干嘛？ 当然是去创建一个.ssh文件夹！ 打开 Git Bash，输入如下命令，然后连续按三个回车即可：ssh-keygen -t rsa -C &quot;your_email@example.com&quot;然后会出来提示Enter file in which to save the key后面是一个路径，你就会找到你想要的.ssh文件夹了，去电脑里找吧。 2.所有文章功能缺失解决方法： 在根目录_config.yml配置文件的最后插入以下代码 123456789101112131415161718jsonContent: meta: false pages: false posts: title: true date: true path: true text: false raw: false content: false slug: false updated: false comments: false link: false permalink: false excerpt: false categories: false tags: true 0x03 域名 主要流程： 购买域名 -&gt; 实名认证 -&gt; 域名解析 -&gt; githubpage绑定域名 前两步没啥好说的，这里主要介绍下后面两步 域名解析里 添加 A 记录 指向以下任意ip 185.199.108.153185.199.109.153185.199.110.153185.199.111.153 source目录里新建一个文件 CNAMEecho unixcs.comecho www.unixcs.com 去github库里 添加一个自定义域名","categories":[],"tags":[{"name":"blog","slug":"blog","permalink":"http://unixcs.com/tags/blog/"}]},{"title":"test","slug":"test","date":"2019-05-31T14:40:31.000Z","updated":"2019-06-01T07:34:38.117Z","comments":true,"path":"/article/2019-05-31/1/","link":"","permalink":"http://unixcs.com/article/2019-05-31/1/","excerpt":"","text":"测试测试测试 hey!hey!hey! hey!hey!hey!","categories":[],"tags":[]},{"title":"Wfuzz初上手","slug":"fuzz","date":"2018-10-27T16:00:00.000Z","updated":"2019-06-02T03:55:32.049Z","comments":true,"path":"/article/2018-10-28/1/","link":"","permalink":"http://unixcs.com/article/2018-10-28/1/","excerpt":"Wfuzz初上手Wfuzz是啥玩意？wfuzz 是一款Python开发的Web安全模糊测试工具。https://github.com/xmendez/wfuzz","text":"Wfuzz初上手Wfuzz是啥玩意？wfuzz 是一款Python开发的Web安全模糊测试工具。https://github.com/xmendez/wfuzz 简单粗暴的功能特点记录： 模块化 框架 可编写插件 接口 可处理BurpSuite所抓的请求和响应报文 简而言之就是wfuzz可以用在做请求参数参数类的模糊测试，也可以用来做Web目录扫描等操作。 Wfuzz初体验 安装Wfuzz pip install wfuzz 简单的使用1wfuzz -w 字典 地址(e.g. https://gh0st.cn/FUZZ) 如上命令使用-w参数指定字典位置，然后跟上一个要测试的地址，所列的例子https://gh0st.cn/FUZZ中有一个FUZZ单词，这个单词可以理解是一个占位符，这样就大概了解了wfuzz的基本运行原理，它会读取字典然后传入占位符进行模糊测试请求。 实际的使用一遍： 1wfuzz -w test_dict.txt https://gh0st.cn/FUZZ 返回结果如下： 12345678910111213141516171819202122********************************************************* Wfuzz 2.2.11 - The Web Fuzzer *********************************************************Target: https://gh0st.cn/FUZZTotal requests: 6==================================================================ID Response Lines Word Chars Payload==================================================================000004: C=404 1 L 121 W 1636 Ch \"test123\"000003: C=404 1 L 121 W 1636 Ch \"456\"000006: C=404 1 L 121 W 1636 Ch \"admin123\"000005: C=404 1 L 121 W 1636 Ch \"admin\"000001: C=404 1 L 121 W 1636 Ch \"abc\"000002: C=404 1 L 121 W 1636 Ch \"123\"Total time: 2.122055Processed Requests: 6Filtered Requests: 0Requests/sec.: 2.827447 通过返回结果我们可以知道很多信息，最需要关注的就是ID、Response、 Lines、Word、Chars、Payload这一行，从左往右看，依次是编号、响应状态码、响应报文行数、响应报文字数、响应报文正字符数、测试使用的Payload。 了解Wfuzz通过-h或者--help可以来获取帮助信息。 Wfuzz模块如上所述说到wfuzz是模块化的框架，wfuzz默认自带很多模块，模块分为5种类型分别是：payloads、encoders、iterators、printers和scripts。 通过-e参数可以查看指定模块类型中的模块列表： 1wfuzz -e payloads payloads类的模块列表如下： 1234567891011121314151617181920212223Available payloads: Name | Summary------------------------------------------------------------------------------------------------------ guitab | This payload reads requests from a tab in the GUI dirwalk | Returns filename's recursively from a local directory. file | Returns each word from a file. burpstate | Returns fuzz results from a Burp state. wfuzzp | Returns fuzz results' URL from a previous stored wfuzz session. ipnet | Returns list of IP addresses of a network. bing | Returns URL results of a given bing API search (needs api key). stdin | Returns each item read from stdin. list | Returns each element of the given word list separated by -. hexrand | Returns random hex numbers from the given range. range | Returns each number of the given range. names | Returns possible usernames by mixing the given words, separated by -, using know | n typical constructions. hexrange | Returns each hex number of the given hex range. permutation | Returns permutations of the given charset and length. buffer_overflow | Returns a string using the following pattern A * given number. iprange | Returns list of IP addresses of a given IP range. burplog | Returns fuzz results from a Burp log. autorize | Returns fuzz results' from autororize. Wfuzz使用从上文知道了wfuzz基于一个非常简单的概念：使用payload来替换相应的FUZZ关键词的位置，FUZZ这样的关键词就是占位符，payload就是输入源。 通过wfuzz -e payloads可以获取payloads类的所有模块列表，使用wfuzz -z help可以获取关于payloads类模块的详细信息，也可以通过--slice参数来过滤返回信息的结果。 e.g. wfuzz -z help --slice &quot;names&quot; 12345678Name: names 0.1Categories: defaultSummary: Returns possible usernames by mixing the given words, separated by -, using known typical constructions.Author: Christian Martorella,Adapted to newer versions Xavi Mendez (@xmendez)Description: ie. jon-smithParameters: + name: Name and surname in the form of name-surname. 使用（字典）注：命令中的wordlist表示为字典位置 wfuzz -z file --zP fn=wordlist URL/FUZZ wfuzz -z file,wordlist URL/FUZZ wfuzz -w wordlist URL/FUZZ 这里有必要说明下，使用命令意义是一样的，都是使用payloads模块类中的file模块，通过wfuzz -z help --slice &quot;file&quot;看如何使用file模块： 12345678Name: file 0.1Categories: defaultSummary: Returns each word from a file.Author: Carlos del Ojo,Christian Martorella,Adapted to newer versions Xavi Mendez (@xmendez)Description: Returns the contents of a dictionary file line by line.Parameters: + fn: Filename of a valid dictionary 通过返回的帮助信息，我们知道这个模块需要一个参数fn，这个参数值为字典文件名（绝对路径）。这样子第一条命令一下子就明白了，wfuzz -z file --zP fn=wordlist URL/FUZZ中的-z file使用模块，--zP fn=wordlist是定义fn参数的值（可以这样理解，–zP 这里的P大写代表 Parameters ，然后其他的都是固有个事） 第二条命令简写了第一条命令的赋值，第三条命令使用-w，这个参数就是-z file --zP fn的别名。 多个字典 使用-z 或-w 参数可以同时指定多个字典，这时相应的占位符应设置为 FUZZ,FUZ2Z,FUZ3Z,….,FUZnZ, 其中n代表了占位序号。 例如想要同时爆破目录、文件名、后缀，可以这样来玩： wfuzz -w 目录字典路径 -w 文件名字典路径 -w 后缀名字典路径 URL/FUZZ/FUZ2Z.FUZ3Z 过滤器wfuzz具有过滤器功能，在做测试的过程中会因为环境的问题需要进行过滤，例如在做目录扫描的时候，你事先探测并知道了这个网站访问不存在目录的时候使用的是自定义404页面（也就是状态码为200），而你可以选择提取该自定义页面的特征来过滤这些返回结果。 wfuzz过滤分为两种方法：隐藏符合过滤条件的结果 和 显示符合过滤条件的结果 隐藏响应结果 通过--hc，--hl，--hw，--hh参数可以隐藏某些HTTP响应。 --hc 根据响应报文状态码进行隐藏（hide code） 隐藏404： wfuzz -w wordlist --hc 404 URL/FUZZ 隐藏404、403： wfuzz -w wordlist --hc 404,403 URL/FUZZ e.g. 使用百度举个例子，运行wfuzz -w test_dict.txt https://www.baidu.com/FUZZ结果如下 这里所有的测试请求，都是不存在的页面，那么百度的404页面规则就是如上图结果所示：响应报文状态码（302）、响应报文行数（7）、响应报文字数（18）、响应报文字符数（222），那么下面的就是填空题了～ --hl根据响应报文行数进行隐藏（hide lines） wfuzz -w wordlist --hl 7 https://www.baidu.com/FUZZ --hw根据响应报文字数进行隐藏（hide word） wfuzz -w wordlist --hw 18 https://www.baidu.com/FUZZ --hh根据响应报文字符数进行隐藏（hide chars 这里因为code和chars首字母都是c，–hc参数已经有了，所以hide chars的参数就变成了–hh） wfuzz -w wordlist --hh 222 https://www.baidu.com/FUZZ 如果根据单个条件判断相对来说肯定是不精确的，所以整合一下就是这样的命令： 1wfuzz -w wordlist --hc 302 --hl 7 --hw 18 --hh 222 https://www.baidu.com/FUZZ 这样就可以对https://www.baidu.com/进行目录扫描咯～ 显示响应结果 显示响应结果的使用方法跟隐藏时的原理一样，只不过参数变为了：--sc（show code），--sl（show lines），--sw（show word），--sh （show chars）。 使用Baseline(基准线) 过滤器可以是某个HTTP响应的引用，这样的引用我们称为Baseline。 之前的使用--hh进行过滤的例子中，还可以使用下面的命令代替： 1wfuzz -w wordlist --hh BBB https://www.baidu.com/FUZZ&#123;404there&#125; 这条命令的意思应该很容易理解，首先要清楚基准线是什么？换个名字：标准线 or 及格线。 首先解释下https://www.baidu.com/FUZZ{404there}的意思，这里代表wfuzz第一个请求是请求https://www.baidu.com/404there这个网址，在{ }内的值用来指定wfuzz第一个请求中的FUZZ占位符，而这第一个请求被标记为BBB（BBB不能换成别的）基准线；其次这里使用的参数是--hh，也就是以BBB这条请求中的Chars为基准，其他请求的Chars值与BBB相同则隐藏。 使用正则表达式过滤 wfuzz参数--ss和--hs可以使用正则表达式来对返回的结果过滤。 e.g. 在这里一个网站自定义返回页面的内容中包含Not Found，想根据这个内容进行过滤可以使用如下的命令： 1wfuzz -w wordlist --hs \"Not Found\" http://127.0.0.1/FUZZ 得出结论使用方法： 12wfuzz -w wordlist --hs 正则表达式 URL/FUZZ #隐藏wfuzz -w wordlist --ss 正则表达式 URL/FUZZ #显示 手册原文来自：DigApis安全 m0nst3r 模块种类payloadpayload为wfuzz生成的用于测试的特定字符串，一般情况下，会替代被测试URL中的FUZZ占位符。当前版本中的wfuzz中可用payloads列表如下： 123456789101112131415161718192021Available payloads: Name | Summary ------------------------------------------------------------------------------------------------------ guitab | 从可视化的标签栏中读取请求 dirwalk | 递归获得本地某个文件夹中的文件名 file | 获取一个文件当中的每个词 autorize | 获取autorize的测试结果Returns fuzz results' from autororize. wfuzzp | 从之前保存的wfuzz会话中获取测试结果的URL ipnet | 获得一个指定网络的IP地址列表 bing | 获得一个使用bing API搜索的URL列表 (需要 api key). stdin | 获得从标准输入中的条目 list | 获得一个列表中的每一个元素，列表用以 - 符号分格 hexrand | 从一个指定的范围中随机获取一个hex值 range | 获得指定范围内的每一个数值 names | 从一个以 - 分隔的列表中，获取以组合方式生成的所有usernames值 burplog | 从BurpSuite的记录中获得测试结果 permutation | 获得一个在指定charset和length时的字符组合 buffer_overflow | 获得一个包含指定个数个A的字符串. hexrange | 获得指定范围内的每一个hex值 iprange | 获得指定IP范围内的IP地址列表 burpstate | 从BurpSuite的状态下获得测试结果 encoderencoder的作用是将payload进行编码或加密。wfuzz的encoder列表如下： 1234567891011121314151617181920212223242526Available encoders: Category | Name | Summary ------------------------------------------------------------------------------------------------------------------------ url_safe, url | urlencode | 用`%xx`的方式替换特殊字符， 字母/数字/下划线/半角点/减号不替换 url_safe, url | double urlencode | 用`%25xx`的方式替换特殊字符， 字母/数字/下划线/半角点/减号不替换 url | uri_double_hex | 用`%25xx`的方式将所有字符进行编码 html | html_escape | 将`&amp;`，`&lt;`，`&gt;`转换为HTML安全的字符 html | html_hexadecimal | 用 `&amp;#xx;` 的方式替换所有字符 hashes | base64 | 将给定的字符串中的所有字符进行base64编码 url | doble_nibble_hex | 将所有字符以`%%dd%dd`格式进行编码 db | mssql_char | 将所有字符转换为MsSQL语法的`char(xx)`形式 url | utf8 | 将所有字符以`\\u00xx` 格式进行编码 hashes | md5 | 将给定的字符串进行md5加密 default | random_upper | 将字符串中随机字符变为大写 url | first_nibble_hex | 将所有字符以`%%dd?` 格式进行编码 default | hexlify | 每个数据的单个比特转换为两个比特表示的hex表示 url | second_nibble_hex | 将所有字符以`%?%dd` 格式进行编码 url | uri_hex | 将所有字符以`%xx` 格式进行编码 default | none | 不进行任何编码 hashes | sha1 | 将字符串进行sha1加密 url | utf8_binary | 将字符串中的所有字符以 `\\uxx` 形式进行编码 url | uri_triple_hex | 将所有字符以`%25%xx%xx` 格式进行编码 url | uri_unicode | 将所有字符以`%u00xx` 格式进行编码 html | html_decimal | 将所有字符以 `&amp;#dd; ` 格式进行编码 db | oracle_char | 将所有字符转换为Oracle语法的`chr(xx)`形式 db | mysql_char | 将所有字符转换为MySQL语法的`char(xx)`形式 iteratorwfuzz的iterator提供了针对多个payload的处理方式。itorators的列表如下： 123456789Available iterators: Name | Summary---------------------------------------------------------------------------------------------- product | Returns an iterator cartesian product of input iterables. zip | Returns an iterator that aggregates elements from each of the iterables. chain | Returns an iterator returns elements from the first iterable until it is exhaust | ed, then proceeds to the next iterable, until all of the iterables are exhausted | . printerwfuzz的printers用于控制输出打印。printers列表如下： 12345678Available printers: Name | Summary -------------------------------------------------- raw | `Raw` output format json | Results in `json` format csv | `CSV` printer ftw magictree | Prints results in `magictree` format html | Prints results in `html` format scriptsscripts列表如下： 1234567891011121314151617Available scripts: Category | Name | Summary---------------------------------------------------------------------------------------------------- default, passive | cookies | 查找新的cookies default, passive | errors | 查找错误信息 passive | grep | HTTP response grep active | screenshot | 用linux cutycapt tool 进行屏幕抓取 default, active, discovery | links | 解析HTML并查找新的内容 default, active, discovery | wc_extractor | 解析subversion的wc.db文件 default, passive | listing | 查找列目录漏洞 default, passive | title | 解析HTML页面的title default, active, discovery | robots | 解析robots.txt文件来查找新内容 default, passive | headers | 查找服务器的返回头 default, active, discovery | cvs_extractor | 解析 CVS/Entries 文件 default, active, discovery | svn_extractor | 解析 .svn/entries 文件 active, discovery | backups | 查找已知的备份文件名 default, active, discovery | sitemap | 解析 sitemap.xml 文件 内置工具wfencode 工具这是wfuzz自带的一个加密/解密（编码/反编码）工具，目前支持内建的encoders的加/解密。 1234wfencode -e base64 123456[RES] MTIzNDU2wfencode -d base64 MTIzNDU2[RES] 123456 wfpayload工具wfpayload是payload生成工具 12345678910111213wfpayload -z range,0-10[RES]012345678910 wxfuzz 工具这个看源码是一个wxPython化的wfuzz，也就是GUI图形界面的wfuzz。目前需要wxPython最新版本才能使用，但是在ParrotOS和Kali上都无法正常安装成功，问题已在GitHub提交Issue，期待开发者的回复中… wfuzz命令中文帮助123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051Usage: wfuzz [options] -z payload,params &lt;url&gt; FUZZ, ..., FUZnZ payload占位符，wfuzz会用指定的payload代替相应的占位符，n代表数字. FUZZ&#123;baseline_value&#125; FUZZ 会被 baseline_value替换，并将此作为测试过程中第一个请求来测试，可用来作为过滤的一个基础。Options: -h/--help : 帮助文档 --help : 高级帮助文档 --version : Wfuzz详细版本信息 -e &lt;type&gt; : 显示可用的encoders/payloads/iterators/printers/scripts列表 --recipe &lt;filename&gt; : 从文件中读取参数 --dump-recipe &lt;filename&gt; : 打印当前的参数并保存成文档 --oF &lt;filename&gt; : 将测试结果保存到文件，这些结果可被wfuzz payload 处理 -c : 彩色化输出 -v : 详细输出 -f filename,printer : 将结果以printer的方式保存到filename (默认为raw printer). -o printer : 输出特定printer的输出结果 --interact : (测试功能) 如果启用，所有的按键将会被捕获，这使得你能够与程序交互 --dry-run : 打印测试结果，而并不发送HTTP请求 --prev : 打印之前的HTTP请求（仅当使用payloads来生成测试结果时使用） -p addr : 使用代理，格式 ip:port:type. 可设置多个代理，type可取的值为SOCKS4,SOCKS5 or HTTP（默认） -t N : 指定连接的并发数，默认为10 -s N : 指定请求的间隔时间，默认为0 -R depth : 递归路径探测，depth指定最大递归数量 -L,--follow : 跟随HTTP重定向 -Z : 扫描模式 (连接错误将被忽视). --req-delay N : 设置发送请求允许的最大时间，默认为 90，单位为秒. --conn-delay N : 设置连接等待的最大时间，默认为 90，单位为秒. -A : 是 --script=default -v -c 的简写 --script= : 与 --script=default 等价 --script=&lt;plugins&gt; : 进行脚本扫描， &lt;plugins&gt; 是一个以逗号分开的插件或插件分类列表 --script-help=&lt;plugins&gt; : 显示脚本的帮助 --script-args n1=v1,... : 给脚本传递参数. ie. --script-args grep.regex=\"&lt;A href=\\\"(.*?)\\\"&gt;\" -u url : 指定请求的URL -m iterator : 指定一个处理payloads的迭代器 (默认为product) -z payload : 为每一个占位符指定一个payload，格式为 name[,parameter][,encoder]. 编码可以是一个列表, 如 md5-sha1. 还可以串联起来, 如. md5@sha1. 还可使用编码各类名，如 url 使用help作为payload来显示payload的详细帮助信息，还可使用--slice进行过滤 --zP &lt;params&gt; : 给指定的payload设置参数。必须跟在 -z 或-w 参数后面 --slice &lt;filter&gt; : 以指定的表达式过滤payload的信息，必须跟在-z 参数后面 -w wordlist : 指定一个wordlist文件，等同于 -z file,wordlist -V alltype : 暴力测试所有GET/POST参数，无需指定占位符 -X method : 指定一个发送请求的HTTP方法，如HEAD或FUZZ -b cookie : 指定请求的cookie参数，可指定多个cookie -d postdata : 设置用于测试的POST data (ex: \"id=FUZZ&amp;catalogue=1\") -H header : 设置用于测试请求的HEADER (ex:\"Cookie:id=1312321&amp;user=FUZZ\"). 可指定多个HEADER. --basic/ntlm/digest auth : 格式为 \"user:pass\" or \"FUZZ:FUZZ\" or \"domain\\FUZ2Z:FUZZ\" --hc/hl/hw/hh N[,N]+ : 以指定的返回码/行数/字数/字符数作为判断条件隐藏返回结果 (用 BBB 来接收 baseline) --sc/sl/sw/sh N[,N]+ : 以指定的返回码/行数/字数/字符数作为判断条件显示返回结果 (用 BBB 来接收 baseline) --ss/hs regex : 显示或隐藏返回结果中符合指定正则表达式的返回结果 --filter &lt;filter&gt; : 显示或隐藏符合指定filter表达式的返回结果 (用 BBB 来接收 baseline) --prefilter &lt;filter&gt; : 用指定的filter表达式在测试之前过滤某些测试条目 ps：本文转自key师傅的博客 –&gt;原文","categories":[],"tags":[]}]}